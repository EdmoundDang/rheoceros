# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

from typing import Dict, List, Sequence, Set, Type, Union

from intelliflow.core.signal_processing import Signal
from intelliflow.core.signal_processing.routing_runtime_constructs import Route

from ...constructs import (
    ConstructInternalMetricDesc,
    ConstructParamsDict,
    ConstructPermission,
    ConstructSecurityConf,
    ProcessorEvent,
    ProcessorQueue,
)
from ..aws_common import AWSConstructMixin


class AWSProcessorQueueBasic(AWSConstructMixin, ProcessorQueue):
    """ProcessorQueue construct impl that is built around SQS.

    Trade-offs:

        Pros:

        Cons:

    """

    def __init__(self, params: ConstructParamsDict) -> None:
        """Called the first time this construct is added/configured within a platform.

        Subsequent sessions maintain the state of a construct, so the following init
        operations occur in the very beginning of a construct's life-cycle within an app.
        """
        super().__init__(params)
        # TODO replace with distributed queue post-MVP
        self._in_memory_queue: List[ProcessorEvent] = []

    def _deserialized_init(self, params: ConstructParamsDict) -> None:
        super()._deserialized_init(params)

    def _serializable_copy_init(self, org_instance: "BaseConstruct") -> None:
        AWSConstructMixin._serializable_copy_init(self, org_instance)
        # reset non-serializables here
        # TODO remove post-MVP
        self._in_memory_queue = []

    def send(
        self,
        events: Union[
            Sequence[ProcessorEvent],
            ProcessorEvent,
            # support Signal for convenience
            Sequence[Signal],
            Signal,
        ],
    ) -> None:
        if events:
            if isinstance(events, (dict, Signal)):
                self._in_memory_queue.append(ProcessorQueue.create_event(events))
            else:
                self._in_memory_queue.extend([ProcessorQueue.create_event(event) for event in events])
        # TODO send _in_memory_queue to SQS

    # TODO return Sequence[QueuedProcessorEvent]
    def receive(self, visibility_timeout_in_seconds: int, max_count: int = None) -> Sequence[ProcessorEvent]:
        # TODO replace post-MVP
        response = [signal for signal in self._in_memory_queue]
        self._in_memory_queue.clear()
        return response

    # TODO expect Sequence[QueuedProcessorEvent]
    def delete(self, events: Sequence[ProcessorEvent]) -> None:
        # TODO implement post-MVP
        pass

    def dev_init(self, platform: "DevelopmentPlatform") -> None:
        super().dev_init(platform)

    def runtime_init(self, platform: "RuntimePlatform", context_owner: "BaseConstruct") -> None:
        """Whole platform got bootstrapped at runtime. For other runtime services, this
        construct should be initialized (ex: context_owner: Lambda, Glue, etc)"""
        AWSConstructMixin.runtime_init(self, platform, context_owner)

    def provide_runtime_trusted_entities(self) -> List[str]:
        return ["sqs.amazonaws.com"]

    def provide_runtime_default_policies(self) -> List[str]:
        return []

    def provide_runtime_permissions(self) -> List[ConstructPermission]:
        return []

    @classmethod
    def provide_devtime_permissions(cls, params: ConstructParamsDict) -> List[ConstructPermission]:
        return []

    def _provide_route_metrics(self, route: Route) -> List[ConstructInternalMetricDesc]:
        # TODO
        return []

    # overrides
    def _provide_internal_metrics(self) -> List[ConstructInternalMetricDesc]:
        """Provide internal metrics (of type INTERNAL_METRIC) that should be managed by RheocerOS and emitted by this
        driver via Diagnostics::emit.
        These metrics are logical metrics generated by the driver (with no assumption on other drivers and other details
        about the underlying platform). So as a driver impl, you want Diagnostics driver to manage those metrics and
        bind them to alarms, etc. Example: Routing metrics.
        """
        return []

    # overrides
    def _provide_internal_alarms(self) -> List[Signal]:
        """Provide internal alarms (of type INTERNAL_ALARM OR INTERNAL_COMPOSITE_ALARM) managed/emitted
        by this driver impl"""
        return []

    def _provide_system_metrics(self) -> List[Signal]:
        """Provide metrics auto-generated by the underlying system components/resources. These metrics types are
        explicit and internally represented as 'external' metric types such as CW_METRIC, etc."""
        return []

    def activate(self) -> None:
        # TODO

        # last action
        super().activate()

    def rollback(self) -> None:
        super().rollback()

    def terminate(self) -> None:
        # IMPL HERE
        # and finally let base know that we are done with the termination
        super().terminate()

    def check_update(self, prev_construct: "BaseConstruct") -> None:
        super().check_update(prev_construct)

    def hook_internal_signal(self, signal: "Signal") -> None:
        # not interested in other signal typs (such as TIMER_EVENT)
        pass

    def _process_security_conf(self, new_security_conf: ConstructSecurityConf, current_security_conf: ConstructSecurityConf) -> None:
        # TODO
        pass

    def _process_external(self, new_signals: Set[Signal], current_signals: Set[Signal]) -> None:
        pass

    def _process_internal(self, new_routes: Set[Route], current_routes: Set[Route]) -> None:
        pass

    def _process_internal_signals(self, new_signals: Set[Signal], current_signals: Set[Signal]) -> None:
        pass

    def _process_construct_connections(
        self, new_construct_conns: Set["_PendingConnRequest"], current_construct_conns: Set["_PendingConnRequest"]
    ) -> None:
        pass

    def _revert_external(self, signals: Set[Signal], prev_signals: Set[Signal]) -> None:
        pass

    def _revert_internal(self, routes: Set[Route], prev_routes: Set[Route]) -> None:
        pass

    def _revert_internal_signals(self, signals: Set[Signal], prev_signals: Set[Signal]) -> None:
        pass

    def _revert_construct_connections(
        self, construct_conns: Set["_PendingConnRequest"], prev_construct_conns: Set["_PendingConnRequest"]
    ) -> None:
        pass

    def _revert_security_conf(selfs, security_conf: ConstructSecurityConf, prev_security_conf: ConstructSecurityConf) -> None:
        pass
